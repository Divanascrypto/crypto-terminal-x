# terminal.py — Crypto Futures Terminal X (No bottom panel + chart legends + improved Demo) # Run: # cd /d %USERPROFILE%\Desktop # py -m pip install fastapi uvicorn requests jinja2 numpy # py -m uvicorn terminal:app --host 127.0.0.1 --port 8000 --reload # Open http://127.0.0.1:8000/?symbol=BTCUSDT&interval=1m&ai=1 import sys, subprocess, json, math, concurrent.futures as cf def _pip(pkg): subprocess.check_call([sys.executable, "-m", "pip", "install", pkg]) for mod,pkg in {"fastapi":"fastapi","uvicorn":"uvicorn","requests":"requests","jinja2":"jinja2","numpy":"numpy"}.items(): try: __import__(mod) except ImportError: _pip(pkg) import requests, numpy as np from fastapi import FastAPI, Request, Query, Response from fastapi.responses import HTMLResponse, JSONResponse from jinja2 import Template from datetime import datetime FAPI = "https://fapi.binance.com" # ---------- Binance helpers ---------- def get_symbols(): try: j = requests.get(f"{FAPI}/fapi/v1/exchangeInfo", timeout=10).json() return [s["symbol"] for s in j["symbols"] if s.get("quoteAsset")=="USDT" and s.get("status")=="TRADING"] except Exception: return ["BTCUSDT","ETHUSDT","BNBUSDT","XRPUSDT","SOLUSDT","ADAUSDT","DOGEUSDT","LTCUSDT","LINKUSDT"] def get_klines(symbol="BTCUSDT", interval="1m", limit=300): try: r = requests.get(f"{FAPI}/fapi/v1/klines", params={"symbol":symbol,"interval":interval,"limit":limit}, timeout=(5,10)) j = r.json() return j if isinstance(j,list) else [] except Exception: return [] def get_24h_tickers(): try: j = requests.get(f"{FAPI}/fapi/v1/ticker/24hr", timeout=10).json() return j if isinstance(j,list) else [] except Exception: return [] SYMS = get_symbols() # ---------- math utils ---------- def to_float(v): try: if v is None: return None v=str(v).strip().replace(",",".") return None if v=="" else float(v) except: return None def to_int(v, d=1): try: if v is None: return d v=str(v).strip() return d if v=="" else int(v) except: return d def to_side(v): v=(v or "").lower() return "short" if v=="short" else "long" def sma(arr, n): out=[]; s=0.0 for i,v in enumerate(arr): s+=v if i>=n: s-=arr[i-n] out.append(s/n if i>=n-1 else None) return out def ema(arr, n): L=len(arr); out=[None]*L if L==0: return out k=2/(n+1); e=None for i,v in enumerate(arr): e=v if e is None else (v*k + e*(1-k)) out[i]=e if i>=n-1 else None return out def rsi(arr, n=14): if len(arr)<n+1: return [None]*len(arr) gains=[0.0]; losses=[0.0] for i in range(1,len(arr)): ch=arr[i]-arr[i-1] gains.append(max(ch,0.0)) losses.append(max(-ch,0.0)) ag=sum(gains[1:n+1])/n; al=sum(losses[1:n+1])/n out=[None]*n for i in range(n,len(arr)): if i>n: ag=(ag*(n-1)+gains[i])/n al=(al*(n-1)+losses[i])/n rs = (ag/al) if al>0 else (math.inf if ag>0 else 0) out.append(100 - (100/(1+rs))) return out def atr(highs,lows,closes,n=14): if len(closes)<n+1: return [None]*len(closes) trs=[None] for i in range(1,len(closes)): tr=max(highs[i]-lows[i], abs(highs[i]-closes[i-1]), abs(lows[i]-closes[i-1])) trs.append(tr) return sma([0 if v is None else v for v in trs], n) def macd_series_py(closes, f=12, s=26, signal=9): e12 = ema(closes, f); e26 = ema(closes, s) macd = [ (e12[i]-e26[i]) if (e12[i] is not None and e26[i] is not None) else None for i in range(len(closes)) ] fill = [0.0 if v is None else v for v in macd] sig = ema(fill, signal) hist = [ (macd[i]-sig[i]) if (macd[i] is not None and sig[i] is not None) else None for i in range(len(closes)) ] return macd, sig, hist def liquidation_price(entry: float, lev: int, side: str, mmr_rate: float): if not entry or not lev or lev<=0: return None if side=="long": denom = (1.0 - mmr_rate) if denom<=0: return None return entry * (1.0 - 1.0/lev) / denom else: return entry * (1.0 + 1.0/lev) / (1.0 + mmr_rate) # ---------- analyzer helpers ---------- def compute_metrics_for_symbol(symbol: str, interval: str): kl=get_klines(symbol, interval, 200) if not isinstance(kl, list) or len(kl)<60: return None closes=[float(k[4]) for k in kl] highs=[float(k[2]) for k in kl] lows =[float(k[3]) for k in kl] qvol=[float(k[7]) for k in kl] chg_pct = (closes[-1]-closes[-30])/closes[-30]*100.0 if len(closes)>30 else (closes[-1]-closes[0])/closes[0]*100.0 e20=ema(closes,20)[-1]; e50=ema(closes,50)[-1]; trend = 1 if (e20 or 0)>(e50 or 0) else -1 rsi_val = rsi(closes,14)[-1] if rsi(closes,14)[-1] is not None else 50.0 avgq = sum(qvol[-21:-1])/max(1,len(qvol[-21:-1])); volx = (qvol[-1]/avgq) if avgq>0 else 1.0 bh = max(highs[-50:-1]); bl = min(lows[-50:-1]); breakout = 1 if closes[-1]>=bh else (-1 if closes[-1]<=bl else 0) atr_arr_ = atr(highs,lows,closes,14); atrv= atr_arr_[-1] if atr_arr_[-1] is not None else 0.0 atr_pct = (atrv/closes[-1]*100.0) if closes[-1]>0 else 0.0 score = (1 if trend>0 else -1) + (1 if volx>=2.0 else 0) + (1 if breakout==1 else (-1 if breakout==-1 else 0)) if 55<=rsi_val<=70: score += 0.5 if 30<=rsi_val<=45: score -= 0.5 signal = "LONG" if score>=2 else ("SHORT" if score<=-2 else "WATCH") return dict(symbol=symbol, chg_pct=round(chg_pct,2), rsi=round(rsi_val,1), trend=trend, vol_x=round(volx,2), breakout=breakout, atr_pct=round(atr_pct,2), signal=signal, score=round(score,2)) def mtf_trend(symbol:str): tfs=["1m","5m","15m","1h","4h"]; out={} for tf in tfs: kl=get_klines(symbol, tf, 120) if not isinstance(kl,list) or len(kl)<60: out[tf]=0; continue closes=[float(k[4]) for k in kl] e20=ema(closes,20)[-1]; e50=ema(closes,50)[-1] out[tf]= 1 if (e20 or 0)>(e50 or 0) else -1 return out # ---------- FastAPI ---------- app = FastAPI() T=Template(r""" <!doctype html> <html> <head> <meta charset="utf-8"/> <title>Crypto Futures Terminal X</title> <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script> <style> :root{ --bg:#0f1115;--panel:#151823;--txt:#e6e6e6;--muted:#9aa4b2;--border:#232738; --live:#73a7ff;--entry:#00b4ff;--sl:#ff4d4f;--tp:#4cd964;--liq:#ffdd33; --demo:#b084f5; } *{box-sizing:border-box} body{background:var(--bg);color:var(--txt);font-family:Inter,Arial,sans-serif;margin:0} header{padding:14px 18px;background:#0c0e13;border-bottom:1px solid var(--border);display:flex;justify-content:space-between;align-items:center} .wrap{display:flex;min-height:calc(100vh - 58px)} .left,.right{width:26rem;padding:16px;background:var(--panel);border-right:1px solid var(--border)} .right{border-right:none;border-left:1px solid var(--border)} .center{flex:1;display:flex;flex-direction:column;padding:16px} .card{background:#0f1320;border:1px solid var(--border);border-radius:12px;padding:12px;margin-bottom:12px} label{font-size:12px;color:var(--muted);display:block;margin-top:10px;margin-bottom:4px} select,input{width:100%;padding:10px 12px;background:#0b0e17;color:#e6e6e6;border:1px solid #2a2f3d;border-radius:10px} button{padding:10px 12px;background:linear-gradient(135deg,#1c2b53,#263b7a);color:#fff;border:none;border-radius:10px;cursor:pointer;font-weight:600} .mini{padding:6px 10px;font-size:12px} .row{display:grid;grid-template-columns:1fr 1fr;gap:10px} .btn-row{display:grid;grid-template-columns:1fr 1fr;gap:10px} .muted{color:var(--muted);font-size:12px} .pill{display:inline-block;padding:4px 8px;border-radius:999px;border:1px solid var(--border);font-size:12px} .badge{padding:2px 6px;border-radius:999px;border:1px solid #2a3150} .ai-long{background:#1f6f43;border-color:#2aa269} .ai-short{background:#6e1f1f;border-color:#b33b3b} .ai-neutral{background:#7a6a21;border-color:#bfa234} table{width:100%;border-collapse:collapse;font-size:12px} th,td{border-bottom:1px solid #252b3a;padding:6px 4px;text-align:left} th{color:#aab4c3} .clickable tr{cursor:pointer} .dot{display:inline-block;width:10px;height:10px;border-radius:50%;margin-right:6px} .dot.g{background:#28c76f}.dot.r{background:#ea5455} </style> </head> <body> <header> <h1>Crypto Futures Terminal X</h1> <div class="muted">Live • Magnets • On-chart legends • AI • Analyzer • Demo (auto-liq)</div> </header> <div class="wrap"> <aside class="left"> <div class="card"> <h3 style="margin:6px 0 10px 0;">Settings (auto-apply)</h3> <form id="theForm" method="get"> <label for="symbolSel">Coin</label> <select name="symbol" id="symbolSel"> {% for s in syms %}<option value="{{s}}" {% if s==symbol %}selected{% endif %}>{{s}}</option>{% endfor %} </select> <label for="tfSel">Timeframe</label> <select name="interval" id="tfSel"> {% for t in ["1m","5m","15m","1h","4h","1d"] %}<option value="{{t}}" {% if t==interval %}selected{% endif %}>{{t}}</option>{% endfor %} </select> <div class="row"> <div><label for="levInp">Leverage (global)</label><input class="auto" id="levInp" type="text" name="lev" value="{{lev}}"></div> <div><label for="sizeInp">Position Size (USDT)</label><input class="auto" id="sizeInp" type="text" name="size" value="{{size}}"></div> </div> <div class="row"> <div><label for="entryInp">Entry</label><input class="auto" id="entryInp" type="text" name="entry" value="{{entry if entry is not none else ''}}"></div> <div><label for="mmrInp">Maintenance Margin % (MMR)</label><input class="auto" id="mmrInp" type="text" name="mmr" value="{{mmr}}"></div> </div> <div class="row"> <div><label for="slInp">Stop Loss (SL)</label><input class="auto" id="slInp" type="text" name="sl" value="{{sl if sl is not none else ''}}"></div> <div><label for="tpInp">Take Profit (TP)</label><input class="auto" id="tpInp" type="text" name="tp" value="{{tp if tp is not none else ''}}"></div> </div> <div class="card" style="margin-top:12px;"> <h4 style="margin:0 0 8px 0;">Fees</h4> <div class="row"> <div><label for="makerFee">Maker fee %</label><input class="auto" id="makerFee" type="text" name="maker_fee" value="{{maker_fee}}"></div> <div><label for="takerFee">Taker fee %</label><input class="auto" id="takerFee" type="text" name="taker_fee" value="{{taker_fee}}"></div> </div> <div class="row" style="margin-top:8px;"> <div><label for="entryTypeSel">Entry execution</label> <select name="entry_type" id="entryTypeSel"> <option value="taker" {% if entry_type=='taker' %}selected{% endif %}>Taker</option> <option value="maker" {% if entry_type=='maker' %}selected{% endif %}>Maker</option> </select> </div> <div><label for="closeTypeSel">Close execution</label> <select name="close_type" id="closeTypeSel"> <option value="taker" {% if close_type=='taker' %}selected{% endif %}>Taker</option> <option value="maker" {% if close_type=='maker' %}selected{% endif %}>Maker</option> </select> </div> </div> </div> <div class="card" style="margin-top:12px;"> <h4 style="margin:0 0 8px 0;">Entry control</h4> <div class="row" style="align-items:center"> <div style="display:flex;align-items:center;gap:8px"> <input type="checkbox" id="lockEntry"> <label for="lockEntry">Lock Entry to Live (seka kainą)</label> </div> <div class="muted">Pažymėjus — Entry juda kartu su kaina</div> </div> </div> <input type="hidden" name="side" value="{{side}}"/> <div class="btn-row" style="margin-top:10px;"> <button type="submit" onclick="this.form.side.value='long';" style="background:linear-gradient(135deg,#106c3a,#1ca24e)">Long</button> <button type="submit" onclick="this.form.side.value='short';" style="background:linear-gradient(135deg,#7a1f1f,#b83030)">Short</button> </div> </form> <div id="pnlText" aria-live="polite" style="margin-top:10px;font-weight:700">P&L: {{pnl}} USDT</div> <div class="muted">Side: <b style="color:#e6e6e6">{{side|capitalize}}</b> • Price: <b id="priceUsed">{{price_used}}</b></div> <div style="margin-top:6px">Liquidation: <span class="pill" id="liqBadge">{{liq_price if liq_price is not none else '-'}}</span></div> <div style="margin-top:6px">ATR(14): <span class="pill">{{atr_val}}</span></div> </div> <div class="card"> <h3 style="margin:6px 0 10px 0;">Legend (kainos + tavo USDT)</h3> <ul style="margin:0 0 0 16px;padding:0"> <li><span class="pill" style="background:var(--entry);border-color:#1a4e66">Entry: <span id="legEntry">-</span></span></li> <li><span class="pill" style="background:var(--sl);border-color:#6b1f1f">SL: <span id="legSL">-</span></span> <span class="pill" id="legSLpnl">-</span></li> <li><span class="pill" style="background:var(--tp);border-color:#1f6f43">TP: <span id="legTP">-</span></span> <span class="pill" id="legTPpnl">-</span></li> <li><span class="pill" style="background:var(--liq);border-color:#6b5a1f">Liq: <span id="legLiq">-</span></span></li> <li><span class="pill" style="background:var(--demo);border-color:#5b3e92">Demo Entry: <span id="demoLegEntry">-</span></span></li> <li><span class="pill" style="background:var(--liq);border-color:#6b5a1f">Demo Liq: <span id="demoLegLiq">-</span></span></li> </ul> </div> <div class="card"> <h3 style="margin:6px 0 10px 0;">Demo Account</h3> <div class="row"> <div><label for="demoBal">Balance (USDT)</label><input id="demoBal" type="text" value="1000"></div> <div><label for="demoSize">Pos Size (USDT)</label><input id="demoSize" type="text" value="50"></div> </div> <div class="row" style="margin-top:8px"> <div><label for="demoLev">Demo Lev</label><input id="demoLev" type="text" value="5"></div> <div><label>&nbsp;</label> <div style="display:flex;gap:8px"> <button id="demoLong" type="button" class="mini">Open LONG</button> <button id="demoShort" type="button" class="mini">Open SHORT</button> </div> </div> </div> <div class="row" style="margin-top:6px"> <button id="demoClose" type="button" class="mini">Close Position</button> <button id="demoReset" type="button" class="mini">Reset History</button> </div> <div class="muted" id="demoInfo" style="margin-top:6px">No open position</div> <div class="muted" id="demoInfo2" style="margin-top:4px">—</div> <div style="max-height:180px;overflow:auto;margin-top:8px"> <table><thead><tr><th>Time</th><th>Side</th><th>Lev</th><th>Entry</th><th>Exit</th><th>P&L</th><th>Reason</th></tr></thead> <tbody id="demoHist"></tbody></table> </div> </div> </aside> <main class="center"> <div id="chart" class="card" style="height:760px;"></div> <div class="card"> <div style="display:flex;align-items:center;gap:10px;justify-content:space-between;flex-wrap:wrap"> <h3 style="margin:0">Market Analyzer</h3> <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap"> <label class="muted" for="scanTf">Interval</label> <select id="scanTf"> <option>1m</option><option>5m</option><option selected>15m</option><option>1h</option><option>4h</option><option>1d</option> </select> <label class="muted" for="scanTop">Top by volume</label> <select id="scanTop"> <option>10</option><option selected>20</option><option>30</option><option>50</option><option>80</option><option>100</option> </select> <label class="muted" for="scanVolX">Min Vol xAvg</label> <select id="scanVolX"> <option value="1">1×</option><option value="1.5" selected>1.5×</option><option value="2">2×</option><option value="3">3×</option><option value="5">5×</option><option value="10">10×</option> </select> <label class="muted" for="scanAtr">Min ATR%</label> <select id="scanAtr"> <option value="0">0%</option><option value="0.5" selected>0.5%</option><option value="1">1%</option><option value="2">2%</option><option value="3">3%</option> </select> <label class="muted" for="scanAlign">MTF align 15m</label> <input id="scanAlign" type="checkbox"> <button id="scanBtn" class="mini" type="button" aria-label="Scan top symbols by volume">Scan</button> <button id="scanOneBtn" class="mini" type="button" aria-label="Analyze current symbol">Analyze current</button> </div> </div> <div class="muted" style="margin:6px 0 10px 0;">Jei nieko neranda – automatiškai silpnina filtrus ir bando dar kartą.</div> <div id="scanMsg" style="display:none;margin:6px 0;color:#ff6b6b"></div> <div id="oneWrap" style="display:none;margin-bottom:10px"> <table class="clickable hi"><thead><tr> <th colspan="9">Current symbol analysis</th></tr> <tr><th>Sym</th><th>%</th><th>RSI</th><th>EMA20&gt;50</th><th>Vol xAvg</th><th>Breakout</th><th>ATR%</th><th>MTF15</th><th>Signal</th></tr></thead> <tbody id="oneBody"></tbody> </table> </div> <div style="max-height:340px;overflow:auto;"> <div id="scanStatus" class="muted" style="display:none;margin:6px 0;">Scanning...</div> <table class="clickable"> <thead><tr> <th>Sym</th><th>%</th><th>RSI</th><th>EMA20&gt;50</th><th>Vol xAvg</th><th>Breakout</th><th>ATR%</th><th>MTF15</th><th>Signal</th> </tr></thead> <tbody id="scanBody"></tbody> </table> </div> </div> <!-- AI Analyzer (Multi-Symbol) --> <div class="card"> <div style="display:flex;align-items:center;gap:10px;justify-content:space-between;flex-wrap:wrap"> <h3 style="margin:0">AI Analyzer (Multi-Symbol)</h3> <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap"> <label class="muted" for="aiTf">Interval</label> <select id="aiTf"> <option>1m</option><option>5m</option><option selected>15m</option><option>1h</option><option>4h</option><option>1d</option> </select> <label class="muted" for="aiTop">Top by volume</label> <select id="aiTop"> <option>10</option><option selected>20</option><option>30</option><option>50</option><option>80</option> </select> <label class="muted" for="aiMinP">Min prob</label> <select id="aiMinP"> <option value="0.52">0.52</option><option value="0.55" selected>0.55</option><option value="0.60">0.60</option><option value="0.65">0.65</option> </select> <button id="aiScanBtn" class="mini" type="button">AI Scan</button> </div> </div> <div id="aiScanStatus" class="muted" style="display:none;margin-top:6px;">Scanning...</div> <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-top:8px;"> <div> <h4 style="margin:4px 0;">LONG candidates</h4> <table class="clickable"> <thead><tr><th>Sym</th><th>Prob</th><th>TP</th><th>SL</th></tr></thead> <tbody id="aiLongBody"></tbody> </table> </div> <div> <h4 style="margin:4px 0;">SHORT candidates</h4> <table class="clickable"> <thead><tr><th>Sym</th><th>Prob</th><th>TP</th><th>SL</th></tr></thead> <tbody id="aiShortBody"></tbody> </table> </div> </div> </div> </main> <aside class="right"> <div class="card" id="mtfCard"> <h3 style="margin:6px 0 10px 6px;">MTF Matrix</h3> <table style="margin:0 6px 8px 6px"> <thead><tr><th>TF</th><th>Trend</th><th>Quick</th></tr></thead> <tbody> <tr><td>1m</td><td id="mtf1m">-</td><td><button id="quick1m" type="button" class="mini">Trade 1m</button></td></tr> <tr><td>5m</td><td id="mtf5m">-</td><td><button id="quick5m" type="button" class="mini">Trade 5m</button></td></tr> <tr><td>15m</td><td id="mtf15m">-</td><td><button id="quick15m" type="button" class="mini">Trade 15m</button></td></tr> <tr><td>1h</td><td id="mtf1h">-</td><td><button id="quick1h" type="button" class="mini">Trade 1h</button></td></tr> <tr><td>4h</td><td id="mtf4h">-</td><td><button id="quick4h" type="button" class="mini">Trade 4h</button></td></tr> </tbody> </table> <div id="mtfNote" class="muted" style="padding:0 6px 6px 6px;">—</div> </div> <div class="card" id="aiCard"> <h3 style="margin:6px 0 10px 6px;">AI Advisor</h3> <div id="aiBox" style="padding:0 6px 6px 6px;"> <div class="muted" id="aiStatus">Paspausk „Analyze (AI)“.</div> <div style="margin-top:6px">Signal: <span class="badge" id="aiSignal">-</span> • Prob: <span class="badge" id="aiProb">-</span></div> <div style="margin-top:6px">AI TP: <span class="pill" id="aiTP">-</span> • AI SL: <span class="pill" id="aiSL">-</span></div> <ul id="aiReasons" style="margin-top:8px"></ul> <div class="btn-row" style="margin-top:8px;"> <button id="aiBtn" type="button" class="mini">Analyze (AI)</button> <button id="aiApply" type="button" class="mini" disabled>Apply AI TP/SL</button> </div> </div> <div class="muted" style="padding:0 6px 6px 6px;">Spalvos: <span style="color:#28c76f">LONG</span> / <span style="color:#ea5455">SHORT</span> / <span style="color:#ffdd33">NEUTRAL</span>.</div> </div> <div class="card"> <h3 style="margin:6px 0 10px 6px;">Info</h3> <div style="padding:0 6px 6px 6px;"> <div>Symbol: <b id="symInfo">{{symbol}}</b></div> <div>Timeframe: <b id="tfInfo">{{interval}}</b></div> <div>Current price: <b id="curPrice">{{current_price}}</b></div> <div class="muted">Maker fee: {{maker_fee}}% • Taker fee: {{taker_fee}}%</div> <div class="muted">Entry exec: {{entry_type|capitalize}} • Close exec: {{close_type|capitalize}}</div> <div class="muted">MMR (approx): {{mmr}}%</div> </div> </div> </aside> </div> <script> // ---- server data ---- const symbol = {{ symbol_json | safe }}; const intervalStr = {{ interval_json | safe }}; let side = {{ side_json | safe }}; let lev = {{ lev_json | safe }}; let sizeUSDT = {{ size_json | safe }}; let entry = {{ entry_json | safe }}; let sl = {{ sl_json | safe }}; let tp = {{ tp_json | safe }}; const makerFeePct = {{ maker_fee_json | safe }}; const takerFeePct = {{ taker_fee_json | safe }}; const entryType = {{ entry_type_json | safe }}; const closeType = {{ close_type_json | safe }}; const mmrPct = {{ mmr_json | safe }}; const mtf = {{ mtf_json | safe }}; let times = {{ times_json | safe }} || []; let opens = {{ opens_json | safe }} || []; let highs = {{ highs_json | safe }} || []; let lows = {{ lows_json | safe }} || []; let closes = {{ closes_json | safe }} || []; let qvol = {{ qvol_json | safe }} || []; // normalize times = Array.isArray(times)? times : []; opens = (opens||[]).map(Number); highs=(highs||[]).map(Number); lows=(lows||[]).map(Number); closes=(closes||[]).map(Number); qvol=(qvol||[]).map(Number); // ---- helpers ---- function hshape(y,color,dash){ if(y==null||!isFinite(y))return null; return {type:'line',xref:'paper',x0:0,x1:1,yref:'y',y0:y,y1:y,line:{color:color,width:2,dash:dash||'solid'}}; } function emaJS(a,n){let out=new Array(a.length).fill(null);if(!a.length)return out;let k=2/(n+1),e=null;for(let i=0;i<a.length;i++){let v=a[i];e=(e===null)?v:(v*k+e*(1-k)); if(i>=n-1) out[i]=e;}return out;} // fees & pnl const feRate = (entryType==='maker' ? makerFeePct : takerFeePct)/100.0; const fcRate = (closeType==='maker' ? makerFeePct : takerFeePct)/100.0; function qty(entryPrice, sz, lv){ return entryPrice ? (sz*lv)/entryPrice : null; } function pnlAt(priceNow){ if(!entry || !priceNow) return null; const q=qty(entry, sizeUSDT, lev); const gross=(side==='long')? (priceNow-entry)*q : (entry-priceNow)*q; const entryFee=entry*q*feRate, exitFee=priceNow*q*fcRate; return gross - entryFee - exitFee; } // main chart layout + shapes + annotations let layout={ title: symbol+" • "+intervalStr, dragmode:'zoom', margin:{r:90,t:30,b:40,l:60}, paper_bgcolor:'#0f1320', plot_bgcolor:'#0f1320', font:{color:'#e6e6e6'}, xaxis:{type:'date',rangeslider:{visible:false},showgrid:false, tickformat:(['1m','5m','15m','1h'].includes(intervalStr)?'%H:%M':(intervalStr==='4h'?'%d %H:%M':'%Y-%m-%d')), showspikes:true,spikethickness:1,spikemode:'across',spikesnap:'cursor'}, yaxis:{showgrid:true,gridcolor:'#1c2333',showspikes:true,spikethickness:1,spikemode:'across',spikesnap:'cursor'}, hovermode:'x unified', hoverlabel:{bgcolor:'#1a2133'}, showlegend:true, legend:{x:1.02,y:1.0, xanchor:'left', yanchor:'top', bgcolor:'#0f1320', bordercolor:'#2a3150', borderwidth:1}, edits:{shapePosition:true}, shapes:[], annotations:[] }; function rebuildShapesInit(){ layout.shapes = []; if(entry!=null) layout.shapes.push(hshape(entry, getComputedStyle(document.documentElement).getPropertyValue('--entry').trim() || 'deepskyblue')); if(sl!=null) layout.shapes.push(hshape(sl, getComputedStyle(document.documentElement).getPropertyValue('--sl').trim() || '#ff4d4f')); if(tp!=null) layout.shapes.push(hshape(tp, getComputedStyle(document.documentElement).getPropertyValue('--tp').trim() || '#4cd964')); } function getShapeY(idx){ try{ const s=layout.shapes[idx]; return (s&&isFinite(s.y0))? s.y0 : null; }catch(_){ return null; } } function annAt(y, txt, color){ if(!isFinite(y)) return null; return {xref:'paper', x:1.01, xanchor:'left', yref:'y', y:y, text:txt, showarrow:false, font:{size:11,color:'#0b0e17',family:'Inter,Arial'}, bgcolor:color, bordercolor:color, opacity:0.9, borderpad:3}; } function rebuildAnnotations(){ const css=getComputedStyle(document.documentElement); const anns=[]; if(SH.live>=0){ const y=getShapeY(SH.live); if(isFinite(y)) anns.push(annAt(y,'LIVE', css.getPropertyValue('--live').trim()||'#73a7ff')); } if(SH.entry>=0){ const y=getShapeY(SH.entry); if(isFinite(y)) anns.push(annAt(y,'ENTRY', css.getPropertyValue('--entry').trim()||'#00b4ff')); } if(SH.sl>=0){ const y=getShapeY(SH.sl); if(isFinite(y)) anns.push(annAt(y,'SL', css.getPropertyValue('--sl').trim()||'#ff4d4f')); } if(SH.tp>=0){ const y=getShapeY(SH.tp); if(isFinite(y)) anns.push(annAt(y,'TP', css.getPropertyValue('--tp').trim()||'#4cd964')); } if(LIQ!=null){ anns.push(annAt(LIQ,'LIQ', css.getPropertyValue('--liq').trim()||'#ffdd33')); } if(SH.demo>=0){ const y=getShapeY(SH.demo); if(isFinite(y)) anns.push(annAt(y,'DEMO', css.getPropertyValue('--demo').trim()||'#b084f5')); } Plotly.relayout('chart',{annotations:anns}); } rebuildShapesInit(); let SH={live:-1, entry:-1, sl:-1, tp:-1, demo:-1}; function indexShapes(){ const arr=layout.shapes||[]; const css=getComputedStyle(document.documentElement); SH.entry = arr.findIndex(s=>s && s.line && (s.line.color===css.getPropertyValue('--entry').trim() || s.line.color==='deepskyblue')); SH.sl = arr.findIndex(s=>s && s.line && (s.line.color===css.getPropertyValue('--sl').trim() || s.line.color==='#ff4d4f')); SH.tp = arr.findIndex(s=>s && s.line && (s.line.color===css.getPropertyValue('--tp').trim() || s.line.color==='#4cd964')); SH.live = arr.findIndex(s=>s && s.line && (s.line.color===css.getPropertyValue('--live').trim() || s.line.color==='#73a7ff')); SH.demo = arr.findIndex(s=>s && s.line && (s.line.color===css.getPropertyValue('--demo').trim() || s.line.color==='#b084f5')); } // traces let chartInited=false; if(times.length && closes.length && times.length===closes.length){ const traces=[{x:times,open:opens,high:highs,low:lows,close:closes,type:'candlestick',name:'Candles', increasing:{line:{width:1.8}},decreasing:{line:{width:1.8}}}]; Plotly.newPlot('chart', traces, layout, {responsive:true}).then(()=>{ chartInited=true; indexShapes(); rebuildAnnotations(); }); } else { document.getElementById('chart').innerHTML = '<div style="padding:12px;color:#ff6b6b">No candle data (mismatch). Perjunk intervalą ar simbolį.</div>'; } // legend / pnl / liq const pnlTextEl = document.getElementById('pnlText'); const liqBadge = document.getElementById('liqBadge'); const legEntry=document.getElementById('legEntry'), legSL=document.getElementById('legSL'), legTP=document.getElementById('legTP'), legLiq=document.getElementById('legLiq'); const legSLpnl=document.getElementById('legSLpnl'), legTPpnl=document.getElementById('legTPpnl'); if(entry!=null) legEntry.textContent = Number(entry).toFixed(6); if(sl!=null){ legSL.textContent = Number(sl).toFixed(6); const v=pnlAt(sl); if(v!=null) legSLpnl.textContent = (v>=0?"+":"")+v.toFixed(2)+" USDT"; } if(tp!=null){ legTP.textContent = Number(tp).toFixed(6); const v=pnlAt(tp); if(v!=null) legTPpnl.textContent = (v>=0?"+":"")+v.toFixed(2)+" USDT"; } function setPnlVisual(pnl){ const txt="P&L: " + (pnl!==null? pnl.toFixed(2): "-") + " USDT"; const color = (pnl>0?'#4cd964':(pnl<0?'#ff4d4f':'#e6e6e6')); pnlTextEl.textContent = txt; pnlTextEl.style.color = color; } function liqPrice(entryPrice, lv, sd, mmrP){ if(!entryPrice || !lv) return null; if(sd==='long'){ const denom=1.0 - (mmrP/100.0); if(denom<=0) return null; return entryPrice*(1.0 - 1.0/lv)/denom; } else { return entryPrice*(1.0 + 1.0/lv)/(1.0 + (mmrP/100.0)); } } const LIQ = liqPrice(entry, lev, side, mmrPct); if(LIQ!=null){ legLiq.textContent = Number(LIQ).toFixed(6); liqBadge.textContent = Number(LIQ).toFixed(6); if(chartInited){ const liqShape = hshape(LIQ, getComputedStyle(document.documentElement).getPropertyValue('--liq').trim() || '#ffdd33', 'dot'); if(liqShape){ layout.shapes = (layout.shapes||[]).concat([liqShape]); Plotly.relayout('chart', {shapes: layout.shapes}); indexShapes(); rebuildAnnotations(); } } } // update a line Y and annotations function setShapeY(idx, y) { if (idx == null || idx < 0 || !isFinite(y)) return; const patch = {}; patch[shapes[${idx}].y0] = y; patch[shapes[${idx}].y1] = y; Plotly.relayout('chart', patch).then(()=>rebuildAnnotations()); } function ensureShape(kind, y, color, dash) { if (!isFinite(y)) return; let add=false; if (kind==='entry' && SH.entry<0) { layout.shapes.push(hshape(y,color,dash)); add=true; } if (kind==='sl' && SH.sl<0) { layout.shapes.push(hshape(y,color,dash)); add=true; } if (kind==='tp' && SH.tp<0) { layout.shapes.push(hshape(y,color,dash)); add=true; } if (kind==='live' && SH.live<0) { layout.shapes.push(hshape(y,color,dash)); add=true; } if (kind==='demo' && SH.demo<0) { layout.shapes.push(hshape(y,color,dash)); add=true; } if(add){ Plotly.relayout('chart',{shapes:layout.shapes}).then(()=>{ indexShapes(); rebuildAnnotations(); }); } } // price polling & kline const curPriceEl= document.getElementById('curPrice'); const priceUsedEl=document.getElementById('priceUsed'); function checkPriceAlerts(p){ if(tp!=null){ const nowAbove = (side==='long') ? p>=tp : p<=tp; if(nowAbove) beep('tp'); } if(sl!=null){ const nowBelow = (side==='long') ? p<=sl : p>=sl; if(nowBelow) beep('sl'); } } let audioCtx=null; function beep(kind){ try{ if(!audioCtx) audioCtx=new (window.AudioContext||window.webkitAudioContext)(); const o=audioCtx.createOscillator(), g=audioCtx.createGain(); let f=600, dur=0.18; if(kind==='tp') { f=880; dur=0.22; } else if(kind==='sl'){ f=320; dur=0.25; } else if(kind==='liq'){ f=200; dur=0.35; } o.frequency.value=f; g.gain.value=0.08; o.connect(g); g.connect(audioCtx.destination); o.start(); setTimeout(()=>{o.stop();}, Math.floor(dur*1000)); }catch(_){} } function applyTick(p){ if(!isFinite(p)) return; curPriceEl.textContent=p.toFixed(6); priceUsedEl.textContent=p.toFixed(6); const pnl=pnlAt(p); setPnlVisual(pnl); checkPriceAlerts(p); // live line ensureShape('live', p, getComputedStyle(document.documentElement).getPropertyValue('--live').trim() || '#73a7ff', 'dot'); setShapeY(SH.live, p); // lock entry? const lock=document.getElementById('lockEntry'); if(lock && lock.checked){ entry = Number(p); const ei=document.getElementById('entryInp'); if(ei) ei.value=entry.toFixed(6); ensureShape('entry', entry, getComputedStyle(document.documentElement).getPropertyValue('--entry').trim() || 'deepskyblue'); setShapeY(SH.entry, entry); const le=document.getElementById('legEntry'); if(le) le.textContent=entry.toFixed(6); } // legend USDT if(sl!=null){ const v=pnlAt(sl); const lslp=document.getElementById('legSLpnl'); if(v!=null && lslp) lslp.textContent=(v>=0?'+':'')+v.toFixed(2)+' USDT'; } if(tp!=null){ const v=pnlAt(tp); const ltpp=document.getElementById('legTPpnl'); if(v!=null && ltpp) ltpp.textContent=(v>=0?'+':'')+v.toFixed(2)+' USDT'; } // demo tick demoTick(p); rebuildAnnotations(); } function applyKlineObj(k){ if(!k) return; const tISO=new Date(k.t).toISOString(); const o=parseFloat(k.o), h=parseFloat(k.h), l=parseFloat(k.l), c=parseFloat(k.c); const vq=parseFloat(k.q || 0); if(times.length && times[times.length-1]===tISO){ opens[opens.length-1]=o; highs[highs.length-1]=h; lows[lows.length-1]=l; closes[closes.length-1]=c; qvol[qvol.length-1]=vq; }else{ times.push(tISO); opens.push(o); highs.push(h); lows.push(l); closes.push(c); qvol.push(vq); } if(chartInited) Plotly.update('chart',{x:[times],open:[opens],high:[highs],low:[lows],close:[closes]},[0]); } // magnet drag → sync with form + legend + annotations + demo document.getElementById('chart').on('plotly_relayout', ev=>{ try{ const key = Object.keys(ev||{}).find(k => /^shapes\[\d+\]\.y[01]$/.test(k)); if(!key) return; const idx = parseInt(key.match(/\[(\d+)\]/)[1]); const y = ev[shapes[${idx}].y0] ?? ev[shapes[${idx}].y1]; if(!isFinite(y)) return; if(idx===SH.entry){ entry=Number(y); const ei=document.getElementById('entryInp'); if(ei) ei.value=entry.toFixed(6); const le=document.getElementById('legEntry'); if(le) le.textContent=entry.toFixed(6); } else if(idx===SH.sl){ sl=Number(y); const si=document.getElementById('slInp'); if(si) si.value=sl.toFixed(6); const lsl=document.getElementById('legSL'); if(lsl) lsl.textContent=sl.toFixed(6); const v=pnlAt(sl); const lslp=document.getElementById('legSLpnl'); if(v!=null && lslp) lslp.textContent=(v>=0?'+':'')+v.toFixed(2)+' USDT'; } else if(idx===SH.tp){ tp=Number(y); const ti=document.getElementById('tpInp'); if(ti) ti.value=tp.toFixed(6); const ltp=document.getElementById('legTP'); if(ltp) ltp.textContent=tp.toFixed(6); const v=pnlAt(tp); const ltpp=document.getElementById('legTPpnl'); if(v!=null && ltpp) ltpp.textContent=(v>=0?'+':'')+v.toFixed(2)+' USDT'; } else if(idx===SH.demo){ demoSetEntry(Number(y)); } rebuildAnnotations(); }catch(_){} }); // polling setInterval(async ()=>{ try{ const r=await fetch('/poll_ticker?symbol='+encodeURIComponent(symbol)); const j=await r.json(); if(j && j.c!=null) applyTick(parseFloat(j.c)); }catch(e){} }, 1200); setInterval(async ()=>{ try{ const r=await fetch('/poll_kline?symbol='+encodeURIComponent(symbol)+'&interval='+encodeURIComponent(intervalStr)); const j=await r.json(); if(j && j.k) applyKlineObj(j.k); }catch(e){} }, 1200); // auto-submit on inputs const form = document.getElementById('theForm'); let submitTimer=null; function scheduleSubmit(){ clearTimeout(submitTimer); submitTimer=setTimeout(()=>form.submit(), 700); } document.querySelectorAll('#theForm .auto').forEach(inp=>{inp.addEventListener('input',scheduleSubmit);inp.addEventListener('change',scheduleSubmit);}); document.getElementById('symbolSel').addEventListener('change', ()=>form.submit()); document.getElementById('tfSel').addEventListener('change', ()=>form.submit()); document.getElementById('entryTypeSel').addEventListener('change', ()=>form.submit()); document.getElementById('closeTypeSel').addEventListener('change', ()=>form.submit()); // ----- Demo account (client-side, with leverage + auto-liq) ----- const demoBalInp = document.getElementById('demoBal'); const demoSizeInp= document.getElementById('demoSize'); const demoLevInp = document.getElementById('demoLev'); const demoLongBtn= document.getElementById('demoLong'); const demoShortBtn= document.getElementById('demoShort'); const demoCloseBtn= document.getElementById('demoClose'); const demoResetBtn= document.getElementById('demoReset'); const demoHistTbody= document.getElementById('demoHist'); const demoInfo = document.getElementById('demoInfo'); const demoInfo2= document.getElementById('demoInfo2'); const demoLegEntry = document.getElementById('demoLegEntry'); const demoLegLiq = document.getElementById('demoLegLiq'); function lsGet(k,d){ try{const v=localStorage.getItem(k); return v? JSON.parse(v): d;}catch(_){return d;} } function lsSet(k,v){ try{localStorage.setItem(k, JSON.stringify(v));}catch(_){} } let demoPos = lsGet('demo_pos', null); // {side, entry, size, lev} let demoHist = lsGet('demo_hist', []); let demoBal = lsGet('demo_bal', parseFloat(demoBalInp.value)||1000); let demoLev = lsGet('demo_lev', parseFloat(demoLevInp.value)||5); demoBalInp.value = demoBal.toString(); demoLevInp.value = demoLev.toString(); function demoRenderHist(){ if(!demoHist.length){ demoHistTbody.innerHTML = '<tr><td colspan="7" class="muted">Empty</td></tr>'; return; } demoHistTbody.innerHTML = demoHist.map(r=><tr><td>${r.t}</td><td>${r.side}</td><td>${r.lev}x</td><td>${Number(r.entry).toFixed(6)}</td><td>${r.exit!=null?Number(r.exit).toFixed(6):'—'}</td><td>${(r.pnl>=0?'+':'')+Number(r.pnl||0).toFixed(2)}</td><td>${r.reason||'—'}</td></tr>).join(''); } function demoQty(){ if(!demoPos) return 0; return qty(demoPos.entry, demoPos.size, demoPos.lev) || 0; } function demoLiq(entryP, levv, sideD){ return liqPrice(entryP, levv, sideD, mmrPct); } function demoEnsureLine(){ if(!demoPos) return; ensureShape('demo', demoPos.entry, getComputedStyle(document.documentElement).getPropertyValue('--demo').trim() || '#b084f5', 'dash'); setShapeY(SH.demo, demoPos.entry); rebuildAnnotations(); } function demoSetEntry(y){ if(!demoPos) return; demoPos.entry = Number(y); lsSet('demo_pos', demoPos); demoLegEntry.textContent = demoPos.entry.toFixed(6); demoUpdateInfo(parseFloat(curPriceEl.textContent)|| (closes.length?closes[closes.length-1]:demoPos.entry)); } function demoUpdateInfo(curP){ if(!demoPos){ demoInfo.textContent = 'No open position'; demoInfo2.textContent='—'; demoLegEntry.textContent='-'; demoLegLiq.textContent='-'; return; } const q = demoQty(); const gross = (demoPos.side==='long' ? (curP-demoPos.entry) : (demoPos.entry-curP)) * q; const pnl = gross - (demoPos.entry*q*(makerFeePct/100)) - (curP*q*(takerFeePct/100)); const margin = (demoPos.size / demoPos.lev); const roe = margin>0 ? (pnl/margin)*100.0 : 0.0; const dLiq = demoLiq(demoPos.entry, demoPos.lev, demoPos.side); demoLegEntry.textContent = demoPos.entry.toFixed(6); demoLegLiq.textContent = dLiq!=null ? Number(dLiq).toFixed(6) : '-'; demoInfo.textContent = Open ${demoPos.side.toUpperCase()} • Lev ${demoPos.lev}x • Qty ${q.toFixed(6)} • Unrealized ${(pnl>=0?'+':'')+pnl.toFixed(2)} USDT (${roe.toFixed(2)}% ROE); demoInfo2.textContent = Margin used ~ ${margin.toFixed(2)} USDT • Demo Liq ${dLiq!=null?Number(dLiq).toFixed(6):'—'}; // auto-liquidation if(dLiq!=null){ if( (demoPos.side==='long' && curP<=dLiq) || (demoPos.side==='short' && curP>=dLiq) ){ beep('liq'); demoClose(curP, 'LIQUIDATION'); } } } function demoOpen(sideDir, curP){ const sz = parseFloat(demoSizeInp.value.toString().replace(',','.')) || 50; const lv = Math.max(1, parseInt(demoLevInp.value.toString().replace(',','.')) || 5); demoLev = lv; lsSet('demo_lev', demoLev); demoPos = { side: sideDir, entry: curP, size: sz, lev: lv }; lsSet('demo_pos', demoPos); demoUpdateInfo(curP); demoEnsureLine(); // Įrašom į formą entry, kad matytum bendrą P&L/liq entry = curP; const ei=document.getElementById('entryInp'); if(ei) ei.value = curP.toFixed(6); ensureShape('entry', entry, getComputedStyle(document.documentElement).getPropertyValue('--entry').trim() || 'deepskyblue'); setShapeY(SH.entry, entry); const le=document.getElementById('legEntry'); if(le) le.textContent=entry.toFixed(6); } function demoClose(curP, reason='MANUAL'){ if(!demoPos) return; const q = demoQty(); const gross = (demoPos.side==='long' ? (curP-demoPos.entry) : (demoPos.entry-curP)) * q; const pnl = gross - (demoPos.entry*q*(makerFeePct/100)) - (curP*q*(takerFeePct/100)); demoBal = (parseFloat(demoBalInp.value.toString().replace(',','.'))||1000) + pnl; demoBalInp.value = demoBal.toFixed(2); lsSet('demo_bal', demoBal); demoHist.unshift({t:new Date().toLocaleString(), side:demoPos.side, lev:demoPos.lev, entry:demoPos.entry, exit:curP, pnl:pnl, reason:reason}); lsSet('demo_hist', demoHist); demoPos=null; lsSet('demo_pos', null); demoRenderHist(); demoInfo.textContent='No open position'; demoInfo2.textContent='—'; demoLegEntry.textContent='-'; demoLegLiq.textContent='-'; // remove demo shape rebuildShapesInit(); Plotly.relayout('chart',{shapes:layout.shapes}).then(()=>{ indexShapes(); rebuildAnnotations(); }); } function demoTick(curP){ if(demoPos) demoUpdateInfo(curP); } demoRenderHist(); demoLongBtn.addEventListener('click', ()=>{ const p=parseFloat(curPriceEl.textContent)|| (closes.length?closes[closes.length-1]:null); if(p) demoOpen('long', p); }); demoShortBtn.addEventListener('click',()=>{ const p=parseFloat(curPriceEl.textContent)|| (closes.length?closes[closes.length-1]:null); if(p) demoOpen('short',p); }); demoCloseBtn.addEventListener('click', ()=>{ const p=parseFloat(curPriceEl.textContent)|| (closes.length?closes[closes.length-1]:null); if(p!=null) demoClose(p, 'MANUAL'); }); demoResetBtn.addEventListener('click', ()=>{ demoHist=[]; lsSet('demo_hist', demoHist); demoRenderHist(); }); // ----- Market Analyzer ----- const scanBtn=document.getElementById('scanBtn'); const scanOneBtn=document.getElementById('scanOneBtn'); const scanBody=document.getElementById('scanBody'); const oneBody=document.getElementById('oneBody'); const oneWrap=document.getElementById('oneWrap'); const scanMsg=document.getElementById('scanMsg'); const scanStatus=document.getElementById('scanStatus'); function rowHtml(r){ const ema = r.trend>0?'YES':'NO'; const br = r.breakout===1?'↑':(r.breakout===-1?'↓':'—'); const m15 = r.mtf15>0?'LONG':(r.mtf15<0?'SHORT':'—'); return <tr data-sym="${r.symbol}"><td>${r.symbol}</td><td>${r.chg_pct}%</td><td>${r.rsi}</td><td>${ema}</td><td>${r.vol_x}×</td><td>${br}</td><td>${r.atr_pct}%</td><td>${m15}</td><td>${r.signal}</td></tr>; } function attachRowClicks(tbody){ tbody.querySelectorAll('tr').forEach(tr=>{ tr.addEventListener('click', ()=>{ const sym=tr.getAttribute('data-sym'); if(!sym) return; const url = new URL(window.location.href); url.searchParams.set('symbol', sym); window.location.href = url.toString(); }); }); } async function scanNow(){ try{ scanMsg.style.display='none'; scanStatus.style.display='block'; scanBody.innerHTML=''; const tf = document.getElementById('scanTf').value; const top= document.getElementById('scanTop').value; const volx=document.getElementById('scanVolX').value; const atr =document.getElementById('scanAtr').value; const align = document.getElementById('scanAlign').checked?1:0; const q = /scan?interval=${encodeURIComponent(tf)}&top=${encodeURIComponent(top)}&volx=${encodeURIComponent(volx)}&atr=${encodeURIComponent(atr)}&align=${encodeURIComponent(align)}; const r=await fetch(q); const j=await r.json(); scanStatus.style.display='none'; const rows=j.rows||[]; if(!rows.length){ scanMsg.textContent='Nieko nerasta pagal filtrus.'; scanMsg.style.display='block'; return; } scanBody.innerHTML = rows.map(rowHtml).join(''); attachRowClicks(scanBody); }catch(e){ scanStatus.style.display='none'; scanMsg.textContent='Klaida skenuojant.'; scanMsg.style.display='block'; } } async function analyzeCurrent(){ try{ oneWrap.style.display='block'; oneBody.innerHTML=''; const q=/analyze?symbol=${encodeURIComponent(symbol)}&interval=${encodeURIComponent(intervalStr)}; const r=await fetch(q); const j=await r.json(); if(!j || !j.row){ oneBody.innerHTML='<tr><td colspan="9">No data</td></tr>'; return; } const rows=[j.row]; oneBody.innerHTML = rows.map(rowHtml).join(''); attachRowClicks(oneBody); }catch(e){ oneBody.innerHTML='<tr><td colspan="9">Error</td></tr>'; } } scanBtn.addEventListener('click', scanNow); scanOneBtn.addEventListener('click', analyzeCurrent); // --- AI Analyzer (multi-symbol) JS --- const aiScanBtn = document.getElementById('aiScanBtn'); const aiScanStatus = document.getElementById('aiScanStatus'); const aiLongBody = document.getElementById('aiLongBody'); const aiShortBody = document.getElementById('aiShortBody'); function aiRow(sym, prob, tp, sl){ const p = (prob*100).toFixed(1)+'%'; const tpv = (tp!=null && isFinite(tp))? Number(tp).toFixed(6) : '—'; const slv = (sl!=null && isFinite(sl))? Number(sl).toFixed(6) : '—'; return <tr data-sym="${sym}"><td>${sym}</td><td>${p}</td><td>${tpv}</td><td>${slv}</td></tr>; } function attachRowClicks(tbl){ tbl.querySelectorAll('tr').forEach(tr=>{ tr.addEventListener('click', ()=>{ const sym=tr.getAttribute('data-sym'); if(!sym) return; const url = new URL(window.location.href); url.searchParams.set('symbol', sym); window.location.href = url.toString(); }); }); } async function aiScanNow(){ try{ aiScanStatus.style.display='block'; aiLongBody.innerHTML=''; aiShortBody.innerHTML=''; const tf = document.getElementById('aiTf').value; const top= document.getElementById('aiTop').value; const minp= document.getElementById('aiMinP').value; const url = /ai_scan?interval=${encodeURIComponent(tf)}&top=${encodeURIComponent(top)}&minp=${encodeURIComponent(minp)}; const r = await fetch(url); const j = await r.json(); aiScanStatus.style.display='none'; const L = j.longs || [], S = j.shorts || []; if(!L.length && !S.length){ aiLongBody.innerHTML='<tr><td colspan="4">—</td></tr>'; aiShortBody.innerHTML='<tr><td colspan="4">—</td></tr>'; return; } aiLongBody.innerHTML = L.map(x=>aiRow(x.symbol, x.prob, x.tp_price, x.sl_price)).join(''); aiShortBody.innerHTML= S.map(x=>aiRow(x.symbol, x.prob, x.tp_price, x.sl_price)).join(''); attachRowClicks(aiLongBody); attachRowClicks(aiShortBody); }catch(e){ aiScanStatus.style.display='none'; aiLongBody.innerHTML='<tr><td colspan="4">Error</td></tr>'; aiShortBody.innerHTML='<tr><td colspan="4">Error</td></tr>'; } } aiScanBtn.addEventListener('click', aiScanNow); // ---------- AI Advisor (single symbol) ---------- const aiBtn = document.getElementById('aiBtn'), aiApply=document.getElementById('aiApply'); const aiStatus=document.getElementById('aiStatus'), aiSignal=document.getElementById('aiSignal'), aiProb=document.getElementById('aiProb'); const aiTP=document.getElementById('aiTP'), aiSL=document.getElementById('aiSL'), aiReasons=document.getElementById('aiReasons'); let lastAI=null; function setAiVisual(sig){ aiSignal.classList.remove('ai-long','ai-short','ai-neutral'); if(sig==='LONG'){ aiSignal.classList.add('ai-long'); } else if(sig==='SHORT'){ aiSignal.classList.add('ai-short'); } else { aiSignal.classList.add('ai-neutral'); } aiSignal.textContent = sig; } async function runAI(){ try{ aiBtn.disabled = true; aiStatus.textContent='AI running...'; const url = /ai_insight?symbol=${encodeURIComponent(symbol)}&interval=${encodeURIComponent(intervalStr)}; const r = await fetch(url); const j = await r.json(); if(!j || j.ok===false){ aiStatus.textContent = j && j.error ? ('AI error: '+j.error) : 'AI error'; aiBtn.disabled = false; aiApply.disabled = true; return; } lastAI = j; setAiVisual(j.signal || 'NEUTRAL'); aiProb.textContent = ((j.prob||0)*100).toFixed(1)+'%'; aiTP.textContent = j.tp_price ? Number(j.tp_price).toFixed(6) : '-'; aiSL.textContent = j.sl_price ? Number(j.sl_price).toFixed(6) : '-'; aiReasons.innerHTML = (j.reasons||[]).map(x=><li>${x}</li>).join(''); aiStatus.textContent = 'AI ready'; aiApply.disabled = !(j.tp_price && j.sl_price); aiBtn.disabled = false; }catch(e){ aiStatus.textContent='AI fetch error'; aiBtn.disabled = false; aiApply.disabled = true; } } aiBtn.addEventListener('click', runAI); aiApply.addEventListener('click', ()=>{ if(!lastAI) return; const tpInp = document.getElementById('tpInp'); const slInp = document.getElementById('slInp'); if(lastAI.tp_price && tpInp){ tpInp.value = Number(lastAI.tp_price).toFixed(6); } if(lastAI.sl_price && slInp){ slInp.value = Number(lastAI.sl_price).toFixed(6); } form.submit(); }); // MTF Matrix function mtfLabel(v){ if(v>0) return '<span class="dot g"></span>LONG'; if(v<0) return '<span class="dot r"></span>SHORT'; return '—'; } function setText(id, html){ const el=document.getElementById(id); if(el) el.innerHTML=html; } setText('mtf1m', mtfLabel(mtf['1m'] || 0)); setText('mtf5m', mtfLabel(mtf['5m'] || 0)); setText('mtf15m', mtfLabel(mtf['15m'] || 0)); setText('mtf1h', mtfLabel(mtf['1h'] || 0)); setText('mtf4h', mtfLabel(mtf['4h'] || 0)); const mtfNote=document.getElementById('mtfNote'); if(mtfNote){ const v1=mtf['1m']||0, v15=mtf['15m']||0; if(v1!==0 && v15!==0 && v1!==v15) mtfNote.textContent = 'Conflict: 1m '+(v1>0?'LONG':'SHORT')+' vs 15m '+(v15>0?'LONG':'SHORT'); else mtfNote.textContent = 'Aligned across key TFs'; } // indeksavimas po starto window.addEventListener('load', ()=>{ indexShapes(); rebuildAnnotations(); if(demoPos){ demoEnsureLine(); demoUpdateInfo(parseFloat(curPriceEl.textContent)|| (closes.length?closes[closes.length-1]:0)); }}); </script> </body> </html> """) @app.get("/", response_class=HTMLResponse) def index(symbol: str = "BTCUSDT", interval: str = "1m", entry: str = "", sl: str = "", tp: str = "", size: str = "50", lev: str = "5", side: str = "long", mmr: str = "0.5", maker_fee: str = "0.02", taker_fee: str = "0.055", entry_type: str = "taker", close_type: str = "taker", safe: str = "1", ai: str = "1", balance: str = "1000"): entry_f=to_float(entry); sl_f=to_float(sl); tp_f=to_float(tp) size_f=to_float(size) or 50.0; lev_i=to_int(lev,5); side_s=to_side(side) mmr_f=(to_float(mmr) or 0.5) maker_fee_f=(to_float(maker_fee) or 0.02)/100.0; taker_fee_f=(to_float(taker_fee) or 0.055)/100.0 entry_type_s=(entry_type or "taker").lower(); close_type_s=(close_type or "taker").lower() balance_f = to_float(balance) or 1000.0 kl=get_klines(symbol, interval, 300) times=[datetime.utcfromtimestamp(k[0]/1000).isoformat()+"Z" for k in kl] opens=[float(k[1]) for k in kl]; highs=[float(k[2]) for k in kl]; lows=[float(k[3]) for k in kl]; closes=[float(k[4]) for k in kl] qvol=[float(k[7]) for k in kl] cur_price=closes[-1] if closes else None price_used=cur_price pnl="-" if entry_f and price_used: q=(size_f*lev_i)/entry_f gross=(price_used-entry_f)*q if side_s=="long" else (entry_f-price_used)*q entry_fee=entry_f*q*(maker_fee_f if entry_type_s=="maker" else taker_fee_f) exit_fee=price_used*q*(maker_fee_f if close_type_s=="maker" else taker_fee_f) pnl=round(gross - entry_fee - exit_fee, 2) atr_arr=atr(highs,lows,closes,14); atr_val = round(atr_arr[-1],6) if atr_arr and atr_arr[-1] is not None else "-" mtf = mtf_trend(symbol) ctx = dict( syms=SYMS, symbol=symbol, interval=interval, entry=entry_f, sl=sl_f, tp=tp_f, size=size_f, lev=lev_i, side=side_s, maker_fee=round(maker_fee_f*100,6), taker_fee=round(taker_fee_f*100,6), entry_type=entry_type_s, close_type=close_type_s, current_price=cur_price, price_used=price_used, pnl=pnl, mmr=mmr_f, liq_price=round(liquidation_price(entry_f, lev_i, side_s, (mmr_f or 0)/100.0),6) if entry_f else None, atr_val=atr_val, mtf=mtf, balance=balance_f ) # JSON blobs ctx.update({ "symbol_json": json.dumps(symbol), "interval_json": json.dumps(interval), "side_json": json.dumps(side_s), "lev_json": json.dumps(lev_i), "size_json": json.dumps(size_f), "entry_json": json.dumps(entry_f), "sl_json": json.dumps(sl_f), "tp_json": json.dumps(tp_f), "maker_fee_json": json.dumps(round(maker_fee_f*100,6)), "taker_fee_json": json.dumps(round(taker_fee_f*100,6)), "entry_type_json": json.dumps(entry_type_s), "close_type_json": json.dumps(close_type_s), "mmr_json": json.dumps(mmr_f), "times_json": json.dumps(times), "opens_json": json.dumps(opens), "highs_json": json.dumps(highs), "lows_json": json.dumps(lows), "closes_json": json.dumps(closes), "qvol_json": json.dumps(qvol), "safe_json": json.dumps(1 if safe=="1" else 0), "ai_json": json.dumps(1 if ai=="1" else 0), "mtf_json": json.dumps(mtf), "balance_json": json.dumps(balance_f), }) return T.render(**ctx) # ---------- Analyzer endpoints ---------- @app.get("/scan") def scan(interval: str = "15m", top: int = 20, volx: float = Query(1.5), atr: float = Query(0.5), align: int = 0): n=max(1,min(int(top),100)) rows=[] # TOP by 24h volume pick=[] try: tickers=get_24h_tickers() syms_set=set(SYMS) vols=[] for t in tickers: s=t.get("symbol") if s in syms_set: try: qv=float(t.get("quoteVolume","0")) except: qv=0.0 vols.append((s,qv)) vols.sort(key=lambda x:x[1], reverse=True) pick=[s for s,_ in vols[:max(n,40)]] except Exception: pick=SYMS[:max(n,50)] def worker(sym): try: r=compute_metrics_for_symbol(sym, interval) if not r: return None if r["vol_x"] < float(volx): return None if r["atr_pct"] < float(atr): return None m15 = mtf_trend(sym).get("15m", 0) if int(align)==1: if (m15>0 and r["trend"]<0) or (m15<0 and r["trend"]>0) or m15==0: return None r["mtf15"]=m15 return r except Exception: return None with cf.ThreadPoolExecutor(max_workers=8) as ex: futs=[ex.submit(worker, s) for s in pick] for f in cf.as_completed(futs): rr=f.result() if rr: rows.append(rr) rows.sort(key=lambda r: r["score"], reverse=True) if not rows: if float(volx)>1.0 or float(atr)>0.0 or int(align)==1: return scan(interval, n, max(1.0, float(volx)/1.5), max(0.0, float(atr)/2.0), 0) return JSONResponse({"rows": rows[:n]}) @app.get("/analyze") def analyze(symbol: str = "BTCUSDT", interval: str = "15m"): row=compute_metrics_for_symbol(symbol, interval) if not row: return JSONResponse({"row": None}) row["mtf15"]=mtf_trend(symbol).get("15m", 0) return JSONResponse({"row": row}) # ---------- realtime poll ---------- @app.get("/poll_ticker") def poll_ticker(symbol: str = "BTCUSDT"): try: r = requests.get(f"{FAPI}/fapi/v1/ticker/price", params={"symbol": symbol}, timeout=5) j = r.json() return JSONResponse({"c": float(j.get("price"))}) except Exception: return JSONResponse({"c": None}) @app.get("/poll_kline") def poll_kline(symbol: str = "BTCUSDT", interval: str = "1m"): try: r = requests.get(f"{FAPI}/fapi/v1/klines", params={"symbol": symbol, "interval": interval, "limit": 1}, timeout=5) arr = r.json() if not isinstance(arr, list) or not arr: return JSONResponse({"k": None}) k = arr[0] kk = {"t": int(k[0]), "o": str(k[1]), "h": str(k[2]), "l": str(k[3]), "c": str(k[4]), "q": str(k[7])} return JSONResponse({"k": kk}) except Exception: return JSONResponse({"k": None}) # ---------- AI endpoint (single symbol) ---------- @app.get("/ai_insight") def ai_insight(symbol: str = "BTCUSDT", interval: str = "15m"): kl = get_klines(symbol, interval, 800) if not isinstance(kl, list) or len(kl) < 200: return JSONResponse({"ok": False, "error": "Not enough data"}) o = np.array([float(k[1]) for k in kl], dtype=float) h = np.array([float(k[2]) for k in kl], dtype=float) l = np.array([float(k[3]) for k in kl], dtype=float) c = np.array([float(k[4]) for k in kl], dtype=float) qv= np.array([float(k[7]) for k in kl], dtype=float) def fill_none(a, fill=0.0): return np.array([fill if (v is None or (isinstance(v,float) and (np.isnan(v)))) else v for v in a], dtype=float) ema20_arr = fill_none(ema(c.tolist(), 20)) ema50_arr = fill_none(ema(c.tolist(), 50)) rsi_arr = fill_none(rsi(c.tolist(), 14), 50.0) macd_arr, sig_arr, hist_arr = macd_series_py(c.tolist(), 12, 26, 9) macd_arr = fill_none(macd_arr); sig_arr = fill_none(sig_arr); hist_arr = fill_none(hist_arr) atr_arr = fill_none(atr(h.tolist(), l.tolist(), c.tolist(), 14), 0.0) # features def sma_np(a, n): out = np.full_like(a, np.nan, dtype=float) if len(a) < n: return out cs = np.cumsum(a, dtype=float) out[n-1:] = (cs[n-1:] - np.concatenate(([0.0], cs[:-n])))/n return out m20 = sma_np(c, 20) std20 = np.full_like(c, np.nan, dtype=float) if len(c) >= 20: for i in range(19, len(c)): std20[i] = np.std(c[i-19:i+1]) with np.errstate(divide='ignore', invalid='ignore'): bb_z = (c - m20) / (2.0*std20) bb_z = np.nan_to_num(bb_z, nan=0.0, posinf=0.0, neginf=0.0) vol_avg20 = np.full_like(qv, np.nan, dtype=float) if len(qv) >= 21: for i in range(20, len(qv)): vol_avg20[i] = np.mean(qv[i-20:i]) with np.errstate(divide='ignore', invalid='ignore'): vol_x = np.divide(qv, vol_avg20) vol_x = np.nan_to_num(vol_x, nan=1.0, posinf=1.0, neginf=1.0) rng = h-l + 1e-12 body = np.abs(c-o) body_pct = body / rng upper_wick = h - np.maximum(c,o) lower_wick = np.minimum(c,o) - l upper_pct = upper_wick / rng lower_pct = lower_wick / rng r1 = np.concatenate(([0], np.diff(c)))/np.clip(c, 1e-9, None) r3 = np.zeros_like(c); r5 = np.zeros_like(c) r3[3:] = (c[3:] - c[:-3])/np.clip(c[:-3], 1e-9, None) r5[5:] = (c[5:] - c[:-5])/np.clip(c[:-5], 1e-9, None) hist = macd_arr - sig_arr hs = np.concatenate(([0], np.diff(hist))) rp100 = np.zeros_like(c) if len(c) >= 100: for i in range(99, len(c)): lo100 = np.min(l[i-99:i+1]); hi100 = np.max(h[i-99:i+1]) rp100[i] = (c[i]-lo100)/(hi100-lo100 + 1e-9) slope20 = np.zeros_like(c) if len(c) >= 20: x = np.arange(20) xm = x.mean(); denom = ((x-xm)**2).sum() + 1e-9 for i in range(19, len(c)): y = c[i-19:i+1] ym = y.mean() slope20[i] = ((x-xm)*(y-ym)).sum()/denom with np.errstate(divide='ignore', invalid='ignore'): slope20n = slope20 / np.clip(c, 1e-9, None) ema_rel = (ema20_arr-ema50_arr)/np.clip(c, 1e-9, None) atr_rel = atr_arr/np.clip(c,1e-9,None) feats = np.column_stack([ r1, r3, r5, (rsi_arr-50.0)/50.0, macd_arr, sig_arr, hist, hs, bb_z, vol_x-1.0, body_pct, upper_pct, lower_pct, rp100, slope20n, ema_rel, atr_rel ]) H=3 y = np.zeros(len(c)-H, dtype=float) for i in range(len(c)-H): y[i] = 1.0 if (c[i+H]-c[i])>0 else -1.0 X = feats[:len(c)-H] mask = np.isfinite(X).all(axis=1) X = X[mask]; y = y[mask] if len(X) < 80: return JSONResponse({"ok": False, "error": "Not enough clean rows"}) lam=1.0 Xb = np.concatenate([X, np.ones((X.shape[0],1))], axis=1) XtX = Xb.T @ Xb XtX += lam * np.eye(XtX.shape[0]) Xty = Xb.T @ y try: w = np.linalg.solve(XtX, Xty) except np.linalg.LinAlgError: w = np.linalg.lstsq(Xb, Xty, rcond=None)[0] x_last = feats[-1] x_last = np.nan_to_num(x_last, nan=0.0, posinf=0.0, neginf=0.0) xb = np.concatenate([x_last, [1.0]]) score = float(xb @ w) prob = 1.0/(1.0 + math.exp(-score)) signal = "NEUTRAL" if prob >= 0.55: signal="LONG" elif prob <= 0.45: signal="SHORT" last_close=float(c[-1]); last_atr=float(atr_arr[-1]) if np.isfinite(atr_arr[-1]) else 0.0 tp_price=sl_price=None if last_atr>0: if signal=="LONG": tp_price = last_close + 1.5*last_atr sl_price = last_close - 1.0*last_atr elif signal=="SHORT": tp_price = last_close - 1.5*last_atr sl_price = last_close + 1.0*last_atr names=["r1","r3","r5","rsiN","macd","sig","hist","histSlope","bbZ","volX-1","body%","upper%","lower%","rangePos100","slope20n","emaRel","atr%"] contrib = (w[:-1] * x_last) idx = np.argsort(-np.abs(contrib))[:4] reasons=[] for i in idx: v=contrib[i]; tag=names[i] txt = f"{tag} {'+' if v>=0 else '−'}{'{:.2f}'.format(abs(v))}" if tag=="emaRel": txt="EMA20>EMA50" if v>=0 else "EMA20<EMA50" if tag=="bbZ": txt=("Price near BB upper" if v>=0 else "Price near BB lower") if tag=="histSlope": txt=("MACD hist rising" if v>=0 else "MACD hist falling") if tag=="rsiN": txt=("RSI bullish bias" if v>=0 else "RSI bearish bias") if tag=="volX-1": txt=("Volume > avg" if v>=0 else "Volume < avg") reasons.append(txt) return JSONResponse({ "ok": True, "signal": signal, "prob": prob, "base_price": last_close, "tp_price": tp_price, "sl_price": sl_price, "reasons": reasons }) # ---------- AI scanner endpoint (multi-symbol) ---------- @app.get("/ai_scan") def ai_scan(interval: str = "15m", top: int = 30, minp: float = 0.55): n = max(5, min(int(top), 80)) pth = max(0.5, min(float(minp), 0.9)) try: tickers = get_24h_tickers() syms_set = set(SYMS) vols = [] for t in tickers: s = t.get("symbol") if s in syms_set: try: qv = float(t.get("quoteVolume","0")) except: qv = 0.0 vols.append((s,qv)) vols.sort(key=lambda x: x[1], reverse=True) pick = [s for s,_ in vols[:max(n,40)]] except Exception: pick = SYMS[:max(n,50)] def compute_for_symbol(sym: str): try: kl = get_klines(sym, interval, 500) if not isinstance(kl, list) or len(kl) < 200: return None import numpy as _np, math as _math o = _np.array([float(k[1]) for k in kl], dtype=float) h = _np.array([float(k[2]) for k in kl], dtype=float) l = _np.array([float(k[3]) for k in kl], dtype=float) c = _np.array([float(k[4]) for k in kl], dtype=float) qv= _np.array([float(k[7]) for k in kl], dtype=float) def _fill(a, fill=0.0): return _np.array([fill if (v is None or (isinstance(v,float) and (_np.isnan(v)))) else v for v in a], dtype=float) ema20 = _fill(ema(c.tolist(), 20)) ema50 = _fill(ema(c.tolist(), 50)) rsi14 = _fill(rsi(c.tolist(), 14), 50.0) macd_, sig_, hist_ = macd_series_py(c.tolist(), 12, 26, 9) macd_ = _fill(macd_); sig_ = _fill(sig_); hist_ = _fill(hist_) atr14 = _fill(atr(h.tolist(), l.tolist(), c.tolist(), 14), 0.0) def _sma_np(a, n): out = _np.full_like(a, _np.nan, dtype=float) if len(a) < n: return out cs = _np.cumsum(a, dtype=float) out[n-1:] = (cs[n-1:] - _np.concatenate(([0.0], cs[:-n])))/n return out m20 = _sma_np(c, 20) std20 = _np.full_like(c, _np.nan, dtype=float) if len(c) >= 20: for i in range(19, len(c)): std20[i] = _np.std(c[i-19:i+1]) with _np.errstate(divide='ignore', invalid='ignore'): bb_z = (c - m20) / (2.0*std20) bb_z = _np.nan_to_num(bb_z, nan=0.0, posinf=0.0, neginf=0.0) vol_avg20 = _np.full_like(qv, _np.nan, dtype=float) if len(qv) >= 21: for i in range(20, len(qv)): vol_avg20[i] = _np.mean(qv[i-20:i]) with _np.errstate(divide='ignore', invalid='ignore'): vol_x = _np.divide(qv, vol_avg20) vol_x = _np.nan_to_num(vol_x, nan=1.0, posinf=1.0, neginf=1.0) rng = h-l + 1e-12 body_pct = _np.abs(c-o) / rng H=3 y = _np.zeros(len(c)-H, dtype=float) for i in range(len(c)-H): y[i] = 1.0 if (c[i+H]-c[i])>0 else -1.0 feats = _np.column_stack([ _np.concatenate(([0], _np.diff(c)))/_np.clip(c, 1e-9, None), (rsi14-50.0)/50.0, macd_, sig_, (macd_-sig_), bb_z, vol_x-1.0, body_pct, (ema20-ema50)/_np.clip(c, 1e-9, None), atr14/_np.clip(c,1e-9,None) ]) X = feats[:len(c)-H] mask = _np.isfinite(X).all(axis=1) X = X[mask]; y2 = y[mask] if len(X) < 80: return None lam=1.0 Xb = _np.concatenate([X, _np.ones((X.shape[0],1))], axis=1) XtX = Xb.T @ Xb XtX += lam * _np.eye(XtX.shape[0]) Xty = Xb.T @ y2 try: w = _np.linalg.solve(XtX, Xty) except _np.linalg.LinAlgError: w = _np.linalg.lstsq(Xb, Xty, rcond=None)[0] x_last = feats[-1] x_last = _np.nan_to_num(x_last, nan=0.0, posinf=0.0, neginf=0.0) xb = _np.concatenate([x_last, [1.0]]) score = float(xb @ w) prob = 1.0/(1.0 + _math.exp(-score)) last_close = float(c[-1]) last_atr = float(atr14[-1]) if _np.isfinite(atr14[-1]) else 0.0 signal = "NEUTRAL" tp_price=sl_price=None if prob >= pth: signal="LONG" elif prob <= (1.0-pth): signal="SHORT" if last_atr>0: if signal=="LONG": tp_price = last_close + 1.5*last_atr sl_price = last_close - 1.0*last_atr elif signal=="SHORT": tp_price = last_close - 1.5*last_atr sl_price = last_close + 1.0*last_atr if signal in ("LONG","SHORT"): return {"symbol": sym, "prob": prob, "signal": signal, "base_price": last_close, "tp_price": tp_price, "sl_price": sl_price} return None except Exception: return None rows = [] with cf.ThreadPoolExecutor(max_workers=8) as ex: futs = [ex.submit(compute_for_symbol, s) for s in pick] for f in cf.as_completed(futs): r = f.result() if r: rows.append(r) longs = [r for r in rows if r["signal"]=="LONG" and r["prob"]>=pth] shorts= [r for r in rows if r["signal"]=="SHORT" and r["prob"]<=1.0-pth] longs.sort(key=lambda x: x["prob"], reverse=True) shorts.sort(key=lambda x: x["prob"]) return JSONResponse({"longs": longs[:n], "shorts": shorts[:n], "minp": pth}) # ---------- misc ---------- @app.get("/favicon.ico") def favicon(): return Response(status_code=204) @app.middleware("http") async def add_csp(request: Request, call_next): resp = await call_next(request) resp.headers["Content-Security-Policy"] = ( "default-src 'self'; " "script-src 'self' 'unsafe-inline' https://cdn.plot.ly; " "style-src 'self' 'unsafe-inline'; " "img-src 'self' data:; " "connect-src 'self' https://fapi.binance.com; " "frame-ancestors 'self'; base-uri 'self'; form-action 'self'" ) resp.headers["X-Content-Type-Options"] = "nosniff" resp.headers["Referrer-Policy"] = "no-referrer" resp.headers["Cache-Control"] = "no-store" return resp if __name__=="__main__": import uvicorn print("🚀 Start: http://127.0.0.1:8000") uvicorn.run(app, host="127.0.0.1", port=8000)
